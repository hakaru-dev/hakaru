# Hakaru Standard Library
# Discrete Distributions: 
#	definitions for distributions with discrete outcomes
# author: Mahmoud Khattab

###########################
# Combinatorial Functions #
###########################

# Definitions for basic Combinatorial Functions used in some functions

# Factorial n! = 1*2*...*(n-1)*n
def factorial(n nat):
	product i from 1 to n+1: i

# Choose function: n C k
# If return w/ real2nat, there are rounding errors

	# OVERFLOW ERRORS with Choose()
	# Overflow error when n is too high. 
	#	E.g choose(30,10) returns 3 and 
	# 	choose(30,15) returns this error:

	#		hakaru: unsafeNat: negative input
	# 		CallStack (from HasCallStack):
  	# 		error, called at haskell/Data/Number/Nat.hs:71:19 in hakaru-0.6.0-AbnzUW5EnqjBuQmLn3LJbU:Data.Number.Nat

def choose(n nat, k nat):
	# TODO error check k <= n
	(product i from k+1 to n+1: i)/(product i from 1 to int2nat(n-k+1): i)


########################################################
# Common Categorical Distributions and Transformations #
########################################################

# Binomial Distribution
# Describes number of successes in n independant experiments
# Each with success probability p
# Current limitations: see choose function comments
def binomial(n nat, p prob):
	arr = array x of n+1:
		real2prob(choose(n,x) * p^x * (1-p)^int2nat(n-x))
	categorical(arr)

# Bernoulli distribution is simply Binomial Distribution of 1 experiment
def bernoulli(p prob):
	binomial(1,p)

# Beta-Binomial is defined as a binomial distribution
# with the success probability pulled from a beta distribution
# Parameters a and b are the shape parameters of the beta distribution
def betaBinomial(a prob, b prob, n nat):
	p <~ beta(a,b)
	binomial(n,p)
# TODO: test betaBinomial correctness. 
# i.e. betaBinomial(1,1,n) should be equivalent to rectangular(n)
# ...doesn't seem to be right now. Although other values of a and b
# create distributions with the expected shape.

# Discrete rectangular distribution.
# Distribution ranges from 0 to n (inclusive) all with the same probability
def rectangular(n nat):
	arr = array x of n+1: 1.0
	categorical(arr)

# Discrete version of the uniform distribution with 
# arbitrarily set min and max values
def discreteUniform(a int,b int):
	# TODO: error check a <= b
	X <~ rectangular(int2nat(b-a))
	return X+a

##################################################
# Gamma-Poisson Distribution and Transformations #
##################################################

# The Gamma-Poisson distribution is defined as a Poisson distribution with a 
# mean selected from a Gamma distribution defined by shape and scale parameters
def gammaPoisson(shape prob, scale prob) measure(nat):
	mu <~ gamma(shape, scale)
	X <~ poisson(mu)
	return X

# Pascal distribution AKA Negative Binomial distribution
# Given an Bernoulli distribution with probability p of success, returns
# the number of successes that occur before n failures occur.	
# Implemented as a case of the gammaPoisson distribution where
# the shape is defined as (1-p)/p and the scale is n
def pascal(n nat, p prob):
	# TODO: error check ensure p<=1
	shape = (1-p)/p
	X <~ gammaPoisson(real2prob(shape), nat2prob(n))
	return X

# Geometric Distribution: case of Pascal distribution with n=1
# i.e. measures number of successes with probability p that will occur
# before a failure occurs.
def geometric(p prob):
	X <~ pascal(1,p)
	return X

# Beta-Pascal Transformations is a case of the Pascal Distribution
# where p is pulled from a Beta Distribution with shape parameters
# a and b
def betaPascal(n nat, a prob, b prob):
	p <~ beta(a,b)
	X <~ pascal(n,p)
	return X

binomial(20, 0.3)